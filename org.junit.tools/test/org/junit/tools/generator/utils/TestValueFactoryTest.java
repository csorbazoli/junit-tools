/** This class was generated by GenTest@Mobacar */
package org.junit.tools.generator.utils;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.nio.charset.Charset;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Date;
import java.util.Deque;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.xml.datatype.XMLGregorianCalendar;

import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.junit.Test;
import org.junit.tools.generator.utils.testmodel.ChildItem;
import org.junit.tools.generator.utils.testmodel.DummyClass;
import org.junit.tools.generator.utils.testmodel.DummyClassIsActive;
import org.junit.tools.generator.utils.testmodel.DummyClassIsActiveNoSetter;
import org.junit.tools.generator.utils.testmodel.DummyClassPrivateSetter;
import org.junit.tools.generator.utils.testmodel.DummyClassThrowingException;
import org.junit.tools.generator.utils.testmodel.DummyClassWithCollections;
import org.junit.tools.generator.utils.testmodel.DummyClassWithDeprecatedFields;
import org.junit.tools.generator.utils.testmodel.DummyClassWithPrimitives;
import org.junit.tools.generator.utils.testmodel.DummyClassWithPublicFields;
import org.junit.tools.generator.utils.testmodel.DummyEnum;
import org.junit.tools.generator.utils.testmodel.ExceptionWithDefaultContstructor;
import org.junit.tools.generator.utils.testmodel.ExceptionWithoutDefaultContstructor;
import org.junit.tools.generator.utils.testmodel.ParentItem;
import org.junit.tools.generator.utils.testmodel.RecursiveChildItem;
import org.junit.tools.generator.utils.testmodel.TestValue;

public class TestValueFactoryTest {

    private Map<String, Integer> map = new HashMap<>();
    private SortedMap<String, Integer> sortedMap = new TreeMap<>();
    private Set<String> set = new HashSet<>();
    private SortedSet<String> sortedSet = new TreeSet<>();

    @Test
    public void testFillNonFinalFields_onlyFinal() throws Exception {
	// given
	DummyClass item = new DummyClass();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals("default", item.getName());
	assertEquals(0, item.getNumber().intValue());
    }

    @Test
    public void testFillNonFinalFields_finalCollections() throws Exception {
	// given
	DummyClassWithCollections item = new DummyClassWithCollections();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals("map value = 123", item.getMap().entrySet().stream()
		.map(e -> e.getKey() + " = " + e.getValue()).collect(Collectors.joining("\n")));
	assertArrayEquals(new Object[] { "names value" }, item.getNames().toArray());
	assertArrayEquals(new Object[] { 123 }, item.getNumbers().toArray());
    }

    @Test
    public void testFillNonFinalFields_primitives() throws Exception {
	// given
	DummyClassWithPrimitives item = new DummyClassWithPrimitives();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals('a', item.getCharacter());
	assertEquals(23.45d, item.getNumericDouble(), 0d);
	assertEquals(37.89f, item.getNumericFloat(), 0d);
	assertEquals(123, item.getNumericInteger());
	assertEquals(123456L, item.getNumericLong());
	assertEquals(27, item.getNumericByte());
    }

    @Test
    public void testFillNonFinalFields_publicFieldsNoSetters() throws Exception {
	// given
	DummyClassWithPublicFields item = new DummyClassWithPublicFields();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals("name value", item.name);
	assertEquals(123, item.number);
    }

    @Test
    public void testFillNonFinalFields() throws Exception {
	// given
	TestValue item = new TestValue();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals("typeName value", item.getTypeName());
	assertEquals("Object", item.getValue());
    }

    @Test
    public void testFillNonFinalFields_privateSetter() throws Exception {
	// given
	DummyClassPrivateSetter item = new DummyClassPrivateSetter();
	// when
	TestValueFactory.fillFields(item);
	// then
	assertEquals(null, item.getName());
	assertEquals(null, item.getNumber());
    }

    @Test
    public void testFindSetterMethod_nonExistent() throws Exception {
	// given
	Class<?> clazz = DummyClass.class;
	Field f = DummyClass.class.getDeclaredField("name");
	// when
	Method actual = TestValueFactory.findSetterMethod(clazz, f);
	// then
	assertNull(actual);
    }

    @Test
    public void testFindSetterMethod_fieldNameStartsWithIs() throws Exception {
	// given
	Class<?> clazz = DummyClassIsActive.class;
	Field f = DummyClassIsActive.class.getDeclaredField("isActive");
	// when
	Method actual = TestValueFactory.findSetterMethod(clazz, f);
	// then
	assertNotNull(actual);
    }

    @Test
    public void testFindSetterMethod_fieldNameStartsWithIsHasPrivateSetter() throws Exception {
	// given
	Class<?> clazz = DummyClassIsActiveNoSetter.class;
	Field f = DummyClassIsActiveNoSetter.class.getDeclaredField("isActive");
	// when
	Method actual = TestValueFactory.findSetterMethod(clazz, f);
	// then
	assertNull(actual);
    }

    @Test
    public void testGetValueForObjects() throws Exception {
	// given
	Class<?> type = Object.class;
	String name = "name";
	Deque<FieldReference> stack = new ArrayDeque<>();
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals("Object", actual);
    }

    @Test
    public void testGetValueForObjects_unhandled() throws Exception {
	// given
	Class<?> type = TestValueFactory.class;
	String name = "name";
	Deque<FieldReference> stack = new ArrayDeque<>();
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(null, actual);
    }

    @Test
    public void testGetValueForPrimitiveTypes() throws Exception {
	// given
	Class<?> type = int.class;
	String name = "name";
	// when
	Object actual = TestValueFactory.getValueForPrimitiveTypes(type, name);
	// then
	assertEquals(123, actual);
    }

    @Test
    public void testGetValueForPrimitiveTypes_double() throws Exception {
	// given
	Class<?> type = double.class;
	String name = "name";
	// when
	Object actual = TestValueFactory.getValueForPrimitiveTypes(type, name);
	// then
	assertEquals(23.45, actual);
    }

    @Test
    public void testGetValueForPrimitiveTypes_nonPrimitive() throws Exception {
	// given
	Class<?> type = Pattern.class;
	String name = "name";
	// when
	Object actual = TestValueFactory.getValueForPrimitiveTypes(type, name);
	// then
	assertEquals(null, actual);
    }

    @Test
    public void testGetValueForPrimitiveTypes_unhandled() throws Exception {
	// given
	Type type = mock(Type.class);
	String name = "name";
	// when
	Object actual = TestValueFactory.getValueForPrimitiveTypes(type, name);
	// then
	assertEquals(null, actual);
    }

    @Test
    public void testGetValueForTypeInner_invalidClass() {
	// given
	Type type = new Type() {
	    @Override
	    public String getTypeName() {
		return "InvalidClass";
	    }
	};
	String name = "name";
	Deque<FieldReference> stack = new ArrayDeque<>();
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertNull(actual);
    }

    @Test
    public void testFillFields_recursive() throws Exception {
	// given
	ParentItem item = new ParentItem();
	// when
	ParentItem actual = TestValueFactory.fillFields(item);
	// then
	assertNotNull(actual);
	assertNotNull(actual.getChildren());
	assertNotNull(actual.getMyName());
    }

    @Test
    public void testFillFields_recursiveListWithDefaultValue() throws Exception {
	// given
	RecursiveChildItem item = new RecursiveChildItem();
	// when
	RecursiveChildItem actual = TestValueFactory.fillFields(item);
	// then
	assertNotNull(actual);
	assertNotNull(actual.getChildren());
    }

    @Test
    public void testFillFields_excludeDeprecated() throws Exception {
	// given
	DummyClassWithDeprecatedFields item = new DummyClassWithDeprecatedFields();
	// when
	DummyClassWithDeprecatedFields actual = TestValueFactory.fillFieldsWithoutDeprecated(item);
	// then
	assertNotNull(actual);
	assertEquals("name value", actual.getName());
	assertEquals(0, actual.getNumber());
    }

    @Test
    public void testFillFields_includeDeprecated() throws Exception {
	// given
	DummyClassWithDeprecatedFields item = new DummyClassWithDeprecatedFields();
	// when
	DummyClassWithDeprecatedFields actual = TestValueFactory.fillFields(item);
	// then
	assertNotNull(actual);
	assertEquals("name value", actual.getName());
	assertEquals(123, actual.getNumber());
    }

    @Test
    public void testGetValueForType_TestValue() throws Exception {
	// given
	Class<?> type = TestValue.class;
	String name = "name";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be TestValue: " + actual.getClass().getName(), actual instanceof TestValue);
	TestValue t = (TestValue) actual;
	assertEquals("typeName value", t.getTypeName());
	assertEquals("Object", t.getValue());
    }

    @Test
    public void testGetValueForType_ParentItem() throws Exception {
	// given
	Class<?> type = ParentItem.class;
	String name = "root";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue(actual instanceof ParentItem);
	ParentItem t = (ParentItem) actual;
	assertEquals("myName value", t.getMyName());
	assertEquals(1, t.getChildren().size());
	ChildItem firstChild = t.getChildren().get(0);
	assertEquals("myName value", firstChild.getMyName());
	assertEquals(t, firstChild.getMyParent());
    }

    @Test
    public void testGetValueForType_String() throws Exception {
	// given
	Class<?> type = String.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals("param value", actual);
    }

    @Test
    public void testGetValueForType_int() throws Exception {
	// given
	Class<?> type = int.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(123, actual);
    }

    @Test
    public void testGetValueForType_Integer() throws Exception {
	// given
	Class<?> type = Integer.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(123, actual);
    }

    @Test
    public void testGetValueForType_byte() throws Exception {
	// given
	Class<?> type = byte.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals((byte) 27, actual);
    }

    @Test
    public void testGetValueForType_boolean() throws Exception {
	// given
	Class<?> type = boolean.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(true, actual);
    }

    @Test
    public void testGetValueForType_char() throws Exception {
	// given
	Class<?> type = char.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals('a', actual);
    }

    @Test
    public void testGetValueForType_long() throws Exception {
	// given
	Class<?> type = long.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(123456L, actual);
    }

    @Test
    public void testGetValueForType_float() throws Exception {
	// given
	Class<?> type = float.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(37.89f, actual);
    }

    @Test
    public void testGetValueForType_set() throws Exception {
	// given
	Type type = getSetType();
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(1, ((Set<?>) actual).size());
	assertEquals("[param value]", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_array() throws Exception {
	// given
	Type type = String[].class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertEquals(1, ((String[]) actual).length);
	assertEquals("[param value]", Arrays.toString((String[]) actual));
    }

    @Test
    public void testGetValueForType_map() throws Exception {
	// given
	Type type = getMapType();
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be Map: " + actual.getClass().getName(), actual instanceof Map);
	assertEquals(1, ((Map<?, ?>) actual).size());
	assertEquals("{param value=123}", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_sortedMap() throws Exception {
	// given
	Type type = getSortedMapType();
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be SortedMap: " + actual.getClass().getName(), actual instanceof SortedMap);
	assertEquals(1, ((Map<?, ?>) actual).size());
	assertEquals("{param value=123}", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_sortedSet() throws Exception {
	// given
	Type type = getSortedSetType();
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be SortedSet: " + actual.getClass().getName(), actual instanceof SortedSet);
	assertEquals(1, ((SortedSet<?>) actual).size());
	assertEquals("[param value]", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_Date() throws Exception {
	// given
	Type type = Date.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be LocalDate: " + actual.getClass().getName(), actual instanceof Date);
	assertEquals("2019-03-26T12:34:56+01:00", formatDateTime((Date) actual));
    }

    @Test
    public void testGetValueForType_LocalDate() throws Exception {
	// given
	Type type = LocalDate.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be LocalDate: " + actual.getClass().getName(), actual instanceof LocalDate);
	assertEquals("2019-03-26", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_LocalTime() throws Exception {
	// given
	Type type = LocalTime.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be LocalTime: " + actual.getClass().getName(), actual instanceof LocalTime);
	assertEquals("12:34:56", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_LocalDateTime() throws Exception {
	// given
	Type type = LocalDateTime.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be LocalDateTime: " + actual.getClass().getName(),
		actual instanceof LocalDateTime);
	assertEquals("2019-03-26T12:34:56", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_GregorianCalendar() throws Exception {
	// given
	Type type = GregorianCalendar.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be DateTime: " + actual.getClass().getName(),
		actual instanceof GregorianCalendar);
	assertEquals("2019-03-26T12:34:56+01:00",
		formatDateTime(((GregorianCalendar) actual).getTime()));
    }

    @Test
    public void testGetValueForType_XMLGregorianCalendar() throws Exception {
	// given
	Type type = XMLGregorianCalendar.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be DateTime: " + actual.getClass().getName(),
		actual instanceof XMLGregorianCalendar);
	assertEquals("2019-03-26T12:34:56.000+01:00", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_URL() throws Exception {
	// given
	Type type = URL.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be URL: " + actual.getClass().getName(), actual instanceof URL);
	assertEquals("http://google.com", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_BigInteger() throws Exception {
	// given
	Type type = BigInteger.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be BigInteger: " + actual.getClass().getName(),
		actual instanceof BigInteger);
	assertEquals(127, ((BigInteger) actual).intValue());
    }

    @Test
    public void testGetValueForType_BigDecimal() throws Exception {
	// given
	Type type = BigDecimal.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be BigDecimal: " + actual.getClass().getName(),
		actual instanceof BigDecimal);
	assertEquals(1023, ((BigDecimal) actual).intValue());
    }

    @Test
    public void testGetValueForType_enum_invalid() throws Exception {
	// given
	Type type = DummyEnum.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be DummyEnum: " + actual.getClass().getName(),
		actual instanceof DummyEnum);
	assertEquals(DummyEnum.VALUE_8, actual);
    }

    @Test
    public void testGetValueForType_enum() throws Exception {
	// given
	Type type = DummyEnum.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be DummyEnum: " + actual.getClass().getName(),
		actual instanceof DummyEnum);
	assertEquals(DummyEnum.VALUE_8, actual);
    }

    @Test
    public void testGetValueForType_locale() throws Exception {
	// given
	Type type = Locale.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be Locale: " + actual.getClass().getName(), actual instanceof Locale);
	assertEquals("en", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_charset() throws Exception {
	// given
	Type type = Charset.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be Charset: " + actual.getClass().getName(), actual instanceof Charset);
	assertEquals("UTF-8", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_pattern() throws Exception {
	// given
	Type type = Pattern.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be Pattern: " + actual.getClass().getName(), actual instanceof Pattern);
	assertEquals(".*", String.valueOf(actual));
    }

    @Test
    public void testGetValueForType_ioException() throws Exception {
	// given
	Type type = IOException.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertNotNull(actual);
	assertTrue("Should be IOException: " + actual.getClass().getName(),
		actual instanceof IOException);
	assertEquals("param value", ((IOException) actual).getMessage());
	assertNotNull(((IOException) actual).getStackTrace());
	assertNotNull(((IOException) actual).getSuppressed());
    }

    @Test
    public void testGetValueForType_exceptionWithDefaultConstructor() throws Exception {
	// given
	Type type = ExceptionWithDefaultContstructor.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertNotNull(actual);
	assertTrue("Should be ExceptionWithDefaultContstructor: " + actual.getClass().getName(),
		actual instanceof ExceptionWithDefaultContstructor);
	assertEquals(null, ((ExceptionWithDefaultContstructor) actual).getMessage());
	assertNotNull(((ExceptionWithDefaultContstructor) actual).getStackTrace());
	assertNotNull(((ExceptionWithDefaultContstructor) actual).getSuppressed());
    }

    @Test
    public void testGetValueForType_exceptionWithoutDefaultConstructor() throws Exception {
	// given
	Type type = ExceptionWithoutDefaultContstructor.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertNull(actual);
    }

    @Test
    public void testGetValueForType_exceptionInConstructor() throws Exception {
	// given
	Type type = DummyClassThrowingException.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertNull(actual);
    }

    @Test
    public void testGetValueForType_inputStream() throws Exception {
	// given
	Type type = InputStream.class;
	String name = "param";
	// when
	Object actual = TestValueFactory.getValueForType(type, name);
	// then
	assertTrue("Should be InputStream: " + actual.getClass().getName(),
		InputStream.class.isAssignableFrom(actual.getClass()));
    }

    // helper methods
    private Type getMapType() throws NoSuchFieldException {
	return this.getClass().getDeclaredField("map").getGenericType();
    }

    private Type getSortedMapType() throws NoSuchFieldException {
	return this.getClass().getDeclaredField("sortedMap").getGenericType();
    }

    private Type getSetType() throws NoSuchFieldException {
	return this.getClass().getDeclaredField("set").getGenericType();
    }

    private Type getSortedSetType() throws NoSuchFieldException {
	return this.getClass().getDeclaredField("sortedSet").getGenericType();
    }

    private String formatDateTime(Date date) {
	return DateTimeFormatter.ISO_DATE_TIME.withZone(ZoneId.of("+01:00")).format(date.toInstant());
    }

}